
package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK, 
	LBRACE, RBRACE, DOT, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE, 
	GT, GE, AND, OR, ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO,
	DO, LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal Absyn.Exp         			Exp;
non terminal Absyn.Var          		Var;
non terminal Absyn.Ty					Type;
non terminal Absyn.TypeDec      		TypeDec, Types;
non terminal Absyn.Dec					Dec;
non terminal Absyn.DecList				DecList;
non terminal Absyn.NameTy 				NameType;
non terminal Absyn.FieldList			Fields, Fields_Rec;
non terminal Absyn.FieldExpList 		fieldExps;
non terminal Absyn.FunctionDec	        functionDec, optFunctions;
non terminal Absyn.ExpList				ExpList, Args, optArgs, seqExp, seqTail;
non terminal Absyn.FieldVar				fieldVar;
non terminal Absyn.SubscriptVar 		subscriptVar;
non terminal Empty;

start with Exp;

Exp ::= error:e
	  {: RESULT = new Absyn.SeqExp(eleft, null); :}
	| Var:v
	  {: RESULT = new Absyn.VarExp(vleft, v); :}
	;

Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	;
